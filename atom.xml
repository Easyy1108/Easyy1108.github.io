<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wellcom</title>
  
  <subtitle>Wellcom!</subtitle>
  <link href="http://easyy1108.github.io/atom.xml" rel="self"/>
  
  <link href="http://easyy1108.github.io/"/>
  <updated>2021-03-18T06:06:46.494Z</updated>
  <id>http://easyy1108.github.io/</id>
  
  <author>
    <name>Easyy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式:观察者模式</title>
    <link href="http://easyy1108.github.io/2021/031710582.html"/>
    <id>http://easyy1108.github.io/2021/031710582.html</id>
    <published>2021-03-17T13:30:29.000Z</published>
    <updated>2021-03-18T06:06:46.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式介绍："><a href="#观察者模式介绍：" class="headerlink" title="观察者模式介绍："></a><font color = #00ffff>观察者模式介绍：</font></h2><p>观察者模式类似于微信公众号的订阅，当公众号发布消息时，所有订阅当前公众号的人都会收到消息。观察者模式定义了一对多的关系，多个观察者对象监听同一个主题对象，当主题对象发生变化时，通知所有观察者对象，使他们能够自动更新。</p><h2 id="观察者结构："><a href="#观察者结构：" class="headerlink" title="观察者结构："></a><font color =#00ffff>观察者结构：</font></h2><ol><li>抽象主题角色（Subject）:抽象主题把所有观察者对象的引用保存在一个列表中，并提供增加和删除观察者对象的操作，一般有叫作抽象观察者角色，通常由抽象类或者接口实现。  </li><li>抽象观察者角色（Observer）：为所有具体观察者定义一个接口，在得到主题通知时更新自己，一般由抽象类或者接口实现。</li><li>具体主题角色（ConCreteSubject）：实现抽象主题接口，又叫作具体被观察者角色。</li><li>集体观察者角色（ConcreteObserver）：实现抽象观察者角色所要求的接口，使自身状态与主题状态相协调。</li></ol><h2 id="观察者模式的简单实现："><a href="#观察者模式的简单实现：" class="headerlink" title="观察者模式的简单实现："></a><font color =#00ffff>观察者模式的简单实现：</font></h2><p>接下来以订阅号为例，实现简单的观察者模式：  </p><ol><li><p><font color = #00ffff>订阅号抽象类：  </font></p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">public abstract class DingYueHao&#123;    &#x2F;&#x2F;保存订阅者的列表    private List&lt;IObserver&gt; observer &#x3D; new  List&lt;Observer&gt;;    public strig Text&#123;get ; set;&#125;    public string Info &#123; get ; set;&#125;    public DingYueHao(string text , string info)&#123;        this.Text&#x3D;text;        this.Info &#x3D;info;    &#125;    &#x2F;&#x2F;加入观察者(订阅的人)    public void AddObserver(IObserver ob)&#123;        observer.Add(ob);    &#125;    &#x2F;&#x2F;移除观察者    public void RemoveObserver(IObserver ob)&#123;        observer.Remove(ob);    &#125;    public void Update()&#123;        &#x2F;&#x2F;遍历订阅的人，进行通知        foreach (IObserver ob in observer)        &#123;            if (ob!&#x3D;null)            &#123;                &#x2F;&#x2F;TODO 通知事项                ob.ReceiveMessage(this);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><font color = #00ffff> 具体的订阅号类 </font>  </p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">public class EasyyGame:DingYueHao&#123;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><font color =#00ffff> 订阅者接口</font></p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">public interface IObserver&#123;    void ReceiveMessage(DingYueHao dyh);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><font color =#00ffff >具体的订阅者 </font></p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">public class Subscriber:IObserver&#123;    public string Name&#123;get;set;&#125;    public Subscriber(string name)&#123;        this.Name &#x3D;name;    &#125;    void ReceiveMessage(DingYueHao dyh)&#123;        console.writeline(&quot;notifide&#123;0&#125;of&#123;1&#125;&quot;+&quot;info is&#123;2&#125;&quot;,Name ,dyh.Text,dyh.Info)    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><font color =#00ffff> 测试类</font></p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">class Test&#123;    static void main(string[] args)&#123;        DingYueHao dyh &#x3D;new EasyyGame(&quot;Easyy!&quot;,&quot;new game published!&quot;);        dyh.AddObserver(new Subscriber(&quot;Tom&quot;));        dyh.Update();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="具体的游戏案例"><a href="#具体的游戏案例" class="headerlink" title="具体的游戏案例"></a>具体的游戏案例</h2><p>我们需要在游戏结束时，利用GameManager 通知所有敌人：玩家已经死亡，停止移动、播放胜利动画等等。<br>订阅者接口：IEndGameObserver  –&gt; Notify()<br>具体主题角色：GameManager<br>观察者：EnemyController</p><ol><li><p><font color = #00ffff> 具体主题角色 </font>  </p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">public GameManager :Mono&#123;    public static GameManager instance;    List&lt;IEndGameObserver&gt; observer &#x3D;new List&lt;IEndGameObserver&gt;;    public void AddObserver(IEndGameObserver ob)&#123;        observer.Add(ob);    &#125;    public void RemoveObserver(IEndGameObserver ob)&#123;        observer.Remove(ob);    &#125;    public void EndNotify()&#123;        foreach (var ob in observer)        &#123;            ob.Notify();        &#125;    &#125;    if (玩家死亡)    &#123;        EndNotify();    &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><font color =#00ffff>订阅者接口</font>  </p><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">public interface IEndGameObserver&#123;    void Notify();&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><font color =#00ffff>订阅者</font>  </p></li></ol><pre class="line-numbers language-cs" data-language="cs"><code class="language-cs">public class EnemyController : Mono ,IEndGameObserver&#123;    instance.AddObserver(this)    void Notify()&#123;        &#x2F;&#x2F;TODO: 玩家死亡之后的一系列动作    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h2><p>优点： </p><ul><li> 观察者模式实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层，即观察者。</li><li> 观察者模式在被观察者和观察者之间建立了一个抽象的耦合，被观察者并不知道任何一个具体的观察者，只是保存着抽象观察者的列表，每个具体观察者都符合一个抽象观察者的接口。  </li><li> 观察者模式支持广播通信。被观察者会向所有的注册过的观察者发出通知。<br>缺点：  </li><li>如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。</li><li>虽然观察者模式可以随时使观察者知道所观察的对象发送了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎样发生变化的。</li><li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，在使用观察者模式应特别注意这点。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h1&gt;&lt;h2 id=&quot;观察者模式介绍：&quot;&gt;&lt;a href=&quot;#观察者模式介绍：&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://easyy1108.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式:单例模式</title>
    <link href="http://easyy1108.github.io/2021/031739727.html"/>
    <id>http://easyy1108.github.io/2021/031739727.html</id>
    <published>2021-03-17T11:29:00.000Z</published>
    <updated>2021-03-17T13:31:43.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ol><li><p><strong>什么是单例模式？</strong><br>单例模式是保证一个类只有一个实例，并且提供一个全局访问点。  </p></li><li><p><strong>如何创建单例模式？</strong>  </p><pre class="line-numbers language-none"><code class="language-none">public class Singleton&#123;        pricate static Singleton Instence;    &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>单例模式使用的场景？</strong><br>单例模式常用与管理类，如GameManager、UIManager、SoundManager等。</p></li><li><p><strong>单例模式与静态类的区别？</strong></p><ul><li>静态类是不可以继承的，因此不能继承MonoBehaviour类。而单例模式可以继承，可以继承MonoBehaviour类，可以在面板显示一些公共属性。</li><li>静态类中的成员会一直保存到应用退出，而单例类的成员会随着场景的切换而被销毁的。  </li></ul></li></ol><h1 id="泛型单例"><a href="#泛型单例" class="headerlink" title="泛型单例"></a>泛型单例</h1><p>优点：可以把所有的单例模式都继承自 泛型单例， 这样就不用在每个单例类中都再写一遍类的实例化。  </p><p>实现：</p><pre class="line-numbers language-none"><code class="language-none">public class Singleton&lt;T&gt; : MonoBehaviour where &lt;T&gt; : Singleton&lt;T&gt;&#123;    &#x2F;&#x2F;私有类型，需要提供公开的访问方法    private static T instence;      &#x2F;&#x2F;提供全局访问点    public static T Instance &#123;        get &#123;return instence;&#125;    &#125;    &#x2F;&#x2F;虚方法，可以在继承类中重写    protected virtual void Awake()&#123;        &#x2F;&#x2F;判断实例是否唯一        if(instence!&#x3D;null)&#123;            Destroy(gameObject);        &#125;else            instance &#x3D;(T)this;    &#125;    &#x2F;&#x2F;判断实例是否被初始化    public static bool IsInitialized&#123;        get&#123; return instance !&#x3D; null &#125;    &#125;    &#x2F;&#x2F;虚方法，可以被重写，如果被销毁，那么设置单例为空    protected virtual void OnDestory()&#123;        if(instance &#x3D;&#x3D; this)            intance &#x3D; null;    &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;什么是单例模式？&lt;/strong&gt;&lt;br&gt;单例模式是保证一个类只有一个实例，并且提供一个全</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://easyy1108.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Unity在安卓上实现简单的相机旋转、缩放</title>
    <link href="http://easyy1108.github.io/2021/031614757.html"/>
    <id>http://easyy1108.github.io/2021/031614757.html</id>
    <published>2021-03-16T03:48:08.000Z</published>
    <updated>2021-03-16T03:49:42.226Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
